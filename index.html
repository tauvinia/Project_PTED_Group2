<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tatiana Blumberg and Tanja Falasca">

<title>Detecting Speed and Route Deviations in Biking Data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Detecting Speed and Route Deviations in Biking Data</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Tatiana Blumberg and Tanja Falasca </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>This project analyzes bicycle riding patterns in Karlsruhe, Germany, using GPS data from the Strava app. The dataset, covering October 1, 2022, to June 1, 2024, includes 347,556 observations. Our focus is on regular commutes between the cyclist’s home and the Hans-Dickmann-Kolleg dormitory. Routes were extracted and assigned unique drive IDs based on time gaps between recordings.</p>
<p>Using R for data manipulation and spatial analysis, we compared route speeds and time spent in green areas. The hypothesis that rides back home take longer was confirmed, but rides back also unexpectedly involved more time in green areas. Various factors, including route preferences and environmental influences, are explored to explain these findings.</p>
<p>The study highlights the utility of combining GPS data with environmental information from OpenStreetMap for urban cycling behavior analysis. The findings provide insights for urban planning and policies to promote cycling as a sustainable transport mode. Challenges such as GPS inaccuracies and data processing issues are discussed, with suggestions for future improvements.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This project aims to conduct a detailed movement tracking analysis, focusing on bicycle riding patterns within an urban environment. Specifically, this study examines data collected from Strava, a popular app used by cyclists to record their rides, which records the GPS points with a certain frequency. The app provides an opportunity to download the pooled data for a specific period but does not identify separate routes, which is one of the preprocessing steps in this project. We utilize R for data manipulation, spatial analysis, and visualization of our results.</p>
<p>For this project the data recorded in the city of Karlsruhe, Germany was used. This data was recorded by one of the team members, Tatiana (further “cyclist”), while she lived there. As we wanted to compare drives that are similar to each other, we opted for one of the regular and the most undertaken route. This is the way between her home and the Hans-Dickmann-Kolleg, the dormitory, where she used to live before and is still involved in many projects. For example, the dormitory has several bars, where the cyclist works from time to time or just visits. Moreover, there are several big festivals a year, in which she normally also takes part.</p>
<p>We studied the route and speed deviations between the ways from home to HaDiKo and back. We expected to encounter deviations in both cases. The initial assumption that on the way to the dormitory the cyclist would drive faster (as having more energy and, maybe, hurrying for the shift) and also spend more time in the green areas (mostly the Schlosspark, through which the fastest route lies) as in this direction she is likely to drive earlier in the day, while in the other direction she might hesitate on taking the forest route due to safety concerns.</p>
<p>Our research area is the spatiotemporal data analysis, as we consider both changes in GPS position and in the timestamps.</p>
</section>
<section id="material-and-methods" class="level2">
<h2 class="anchored" data-anchor-id="material-and-methods">Material and Methods</h2>
<p>In our research, we used biking data from the Strava app, collected between October 1, 2022, and June 1, 2024. The dataset contains 347,556 observations. To expedite the calculations, we initially tested the code on a smaller dataset with 21,459 observations collected between April 5, 2024, and April 14, 2024. This dataset includes variables such as timestamp, latitude, longitude, and elevation. During the drive, the GPS location is recorded every second, but if the cyclist pauses, the recordings are made less frequently. For the convenience of further calculations, we separated the timestamp into date and time. We were interested only in the routes taken between two specific points: Kriegsstraße 183, 76135 Karlsruhe, Germany (referred to as “home”) and Hans-Dickmann-Kolleg located at Klosterweg 28, 76131 Karlsruhe, Germany (referred to as “Hadiko”). To compare the routes, we first had to extract each drive and separate them in the dataset. To achieve this, any observation recorded more than 300 seconds after the previous one was counted as the start of a new drive. Each drive was then assigned a unique ID.</p>
<p>To filter out the drives between the two points of interest, we developed a function that created a buffer around the start and end points. The function then filtered the data based on the criteria to include only drives where the first recording falls within the start buffer and the last recording falls within the end buffer. Additionally, the function generated a plot illustrating the drives, the start and end points, and the created buffers to verify the accuracy of the results. Using this function, we filtered drives from “home” to “Hadiko” (“there”) and from “Hadiko” to “home” (“back”), using a buffer size of 500 meters. To gain a better overview of the study area, we created a bounding box around the relevant data points. By grouping the data using “group by”, we obtained a summary of how many routes exist in each category.</p>
<p>To relate the data to the environment, we extracted features stored in the Open Street Map, which we could access using the OpenStreetMap library in R. To get an overview of the roads, we extracted all the roads stored in the Highway key and created a road network from this data. To obtain the green spaces in our study area, we extracted the parks, forests, and lawns from the open data. The forests were stored in polygons and multipolygons in the tag:landuse=forest, with varying degrees of equality and sometimes overlapping. There was also an overlapping with the parks. As parks and forests within a city share a similar purpose, we merged these features to refer to them collectively as green spaces. We decided not to take the grass areas into account, as they often overlapped with forest and park areas and did not significantly interfere with our movement data. To obtain a good overview of the extracted features, we visualized them in the graphic below along with the movement data.</p>
<p>To compare biking routes with different starting points, we first calculated the duration of each route. We achieved this by creating a function in R that grouped the data by drive and then calculated the time difference between each GPS point in the group. Summing these time differences provided us with the total time each route took. To further compare the biking routes, we examined whether they differed in the time spent biking through green areas. We accomplished this by filtering the points located within green areas, grouping them by each drive, and then calculating the time spent in these areas using the same function we used for calculating the overall drive times. Since the number of biking routes varied for each starting point, we calculated the percentage of time spent in green areas for each route. This approach allows for a fair comparison of values across the different starting points.</p>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>The duration per drive (see <a href="#fig-duration" class="quarto-xref">Figure&nbsp;1</a>) was longer for the routes from Hadiko to Home. Additionally, more time was spent in green areas by routes from HaDiKo to Home (see <a href="#fig-greenareas" class="quarto-xref">Figure&nbsp;3</a>). For this the mapmatching of the routes was done, with different colour corresponding to different environment categories, see <a href="#fig-map" class="quarto-xref">Figure&nbsp;2</a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">boxplot</span>(duration_from_home<span class="sc">$</span>difftime, duration_from_hadiko<span class="sc">$</span>difftime,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>        <span class="at">main =</span> <span class="st">"Duration per Drive"</span>,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">las =</span> <span class="dv">2</span>,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">col =</span> <span class="fu">c</span>(<span class="st">"steelblue4"</span>, <span class="st">"darkred"</span>),</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">ylab =</span> <span class="st">"Minutes"</span>,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="at">xlab =</span> <span class="st">"Startpoint"</span>,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">names =</span> <span class="fu">c</span>(<span class="st">"Home"</span>, <span class="st">"Hadiko"</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-duration" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-duration-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-duration-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-duration-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Duration of drives
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Data from home</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> street_network <span class="sc">%&gt;%</span> <span class="fu">activate</span>(edges) <span class="sc">%&gt;%</span> <span class="fu">st_as_sf</span>(), <span class="at">size =</span> <span class="dv">2</span>, <span class="at">color =</span> <span class="st">"lightgrey"</span>) <span class="sc">+</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> green_spaces, <span class="at">color =</span> <span class="st">"darkolivegreen2"</span>, <span class="at">fill =</span> <span class="st">"darkolivegreen2"</span>) <span class="sc">+</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> data_from_home, <span class="at">color =</span> <span class="st">"steelblue1"</span>, <span class="at">size =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> green_spaces_from_home, <span class="at">color =</span> <span class="st">"steelblue4"</span>, <span class="at">size =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_void</span>() <span class="sc">+</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggtitle</span>(<span class="st">"Drives from Home to Hadiko"</span>) <span class="sc">+</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>)) <span class="sc">+</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Data from Hadiko</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> street_network <span class="sc">%&gt;%</span> <span class="fu">activate</span>(edges) <span class="sc">%&gt;%</span> <span class="fu">st_as_sf</span>(), <span class="at">size =</span> <span class="dv">2</span>, <span class="at">color =</span> <span class="st">"lightgrey"</span>) <span class="sc">+</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> green_spaces, <span class="at">color =</span> <span class="st">"darkolivegreen2"</span>, <span class="at">fill =</span> <span class="st">"darkolivegreen2"</span>) <span class="sc">+</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> data_from_hadiko, <span class="at">color =</span> <span class="st">"brown1"</span>, <span class="at">size =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> green_spaces_from_hadiko, <span class="at">color =</span> <span class="st">"darkred"</span>, <span class="at">size =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_void</span>() <span class="sc">+</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggtitle</span>(<span class="st">"Drives from Hadiko to Home"</span>) <span class="sc">+</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-map" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-map-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-map-1.png" class="img-fluid figure-img" width="960">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-map-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Mapmatching of the routes
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">boxplot</span>(green_spaces_from_home<span class="sc">$</span>percentage_green_space, green_spaces_from_hadiko<span class="sc">$</span>percentage_green_space,</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>        <span class="at">main =</span> <span class="st">"Percentage of Time Spent in Green Spaces per Drive"</span>,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">las =</span> <span class="dv">2</span>,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">col =</span> <span class="fu">c</span>(<span class="st">"steelblue4"</span>, <span class="st">"darkred"</span>),</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">ylab =</span> <span class="st">"Percentage"</span>,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="at">xlab =</span> <span class="st">"Startpoint"</span>,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">names =</span> <span class="fu">c</span>(<span class="st">"Home"</span>, <span class="st">"Hadiko"</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-greenareas" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-greenareas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-greenareas-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-greenareas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Time spent in green areas
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
</section>
<section id="results-interpretation" class="level1">
<h1>Results’ Interpretation</h1>
<p>The time difference matched our expectations: the way there took on average more time than the way back. This could be explained that first the cyclist had more energy or had to hurry to the bar shift but on the way back she was tired and did not have any time pressure.</p>
<p>However, the second result turned out to be surprising. We expected the cyclist to spend less time in the forest on the way back since it was usually late at this point, and if returning alone, she would opt for the city area. Nevertheless, although, showing less discrepancy, the average time in the green areas for the way back was higher. We came up with several explanations for this phenomenon. First, since the way “back” took in general longer than “there”, this would also mean that, when opted for the forest route, the cyclist would also spend more time in it. Second, as it is shown on the visualisation, the cyclist several times took the city route on the way there (e.g.&nbsp;if it was already too dark to use the forest route or if she had to visit some places on the way). This could lead to the number of the forest routes “there” and forest routes “back” closer than expected. Third, during the recorded period, she did not necessary drive back alone, in which case the forest route was preferred as the fastest. Fourth, as shown on the visualisation, one of the roads lies next to a small green area, which was also counted as time spent in green due to the GPS imprecision, but only on the way back (since the road in the other direction is significantly further away from the park).</p>
</section>
<section id="challenges" class="level1">
<h1>Challenges</h1>
<p>We encountered some problems while trying to extract the routes. The initial idea was to find all the points recorded within the buffer and then choose the closest to the start/end points for every day. However, later we realised that due to imprecision of the GPS tracking, the closest point is not necessarily the first one and there might be several recordings per day starting at our “home” point, which made grouping by time pointless, so we switched to the first/last point per drive. We wanted to use the temporal criterion for matching “there” and “back” routes as well (both happening in the same day) but since there is a chance that the way “back” was recorded after midnight we had to abandon this idea. In the end we decided to give up the route matching at all and to compare the “there” and “back” groups as a whole. The decision was proven right when we found out that due to the measurement error (inconsistency) the number of recordings in the two categories did not match. The solution of the drive separation problem (5 minutes pause as a breaking point) does not seem to be ideal, as there is a chance of the cyclist making longer breaks still within one route which would result in us losing some drives while filtering. Finding the better alternative could be a subject of future work.</p>
</section>
<section id="further-steps" class="level1">
<h1>Further Steps</h1>
<p>The work could be continued at a more detailed level. For instance, after identifying differences in the time spent in green areas for the outbound and return journeys, one could pair the outbound journeys with the corresponding return journeys and then compare these drives. This comparison could be conducted using similarity measures or by comparing the drives to the shortest possible route from the start to the endpoint, which could be calculated from the street network data we have already obtained in R with the shortest path function. Further, one could examine speed deviations during the drives and make assumptions about their nature by extracting additional features from OpenStreetMap. For example, one could investigate where the route deviates from the usual path and whether there are any pauses in the journey. To investigate the reasons for these pauses, one could check if the proximity to certain features, such as grocery stores or post offices, suggests that the deviation was made to do some shopping or send/receive a package.</p>
<p>From the speed perspective one could compute the average speed for every route in the dataset, then the average speed for the whole dataset and look at the drives that are deviating from it the most (1st and 4th quartile). Then one could search for similarities between the routes of one quartile (for example, whether the cyclist goes faster in specific locations or specific days of the week/time of the day. Alternatively, the end point of the route could be plotted on the map which would allow to make some assumptions. In case where, for instance, the speed is higher than average and the end point is a medical cabinet, one could assume that the cyclist was hurrying to an appointment).</p>
<p>The speed could also be compared within one drive if it is sufficiently long: did the cyclist keep the same speed all the time or was faster in the beginning and then got tired and lost the speed towards the end?</p>
</section>
<section id="openstreetmap-data" class="level1">
<h1>OpenStreetMap Data</h1>
<p>OpenStreetMap provides a vast amount of openly accessible data contributed by a large number of non-commercialized users. Due to the varying levels of user experience, errors can occur in the data, and not all areas may be covered with the same amount of information (<span class="citation" data-cites="sehra2013">Sehra, Singh, and Rai (<a href="#ref-sehra2013" role="doc-biblioref">2013</a>)</span>). We encountered the challenge of inconsistency in OpenStreetMap while extracting greenspaces, due to the information being stored in different formats (polygons and multipolygons) and overlapping with each other. Addressing topology errors was also necessary during the process. Moreover, uncertainty remains regarding the completeness and accuracy of the data coverage. A further challenge was that occasionally, we encountered issues with a general Overpass server error when attempting to access this data. To address this problem, we stored the boundary data locally on our computers, ensuring continuous access to this data at any time. Nevertheless, OpenStreetMap proved invaluable as it facilitated easy access to environmental information, enabling us to analyse our data in relation to the environment effectively.</p>
</section>
<section id="artificial-intelligence" class="level1">
<h1>Artificial Intelligence</h1>
<p>In this project, we used ChatGPT as inspiration when encountering errors in our code. We did not use ChatGPT to write the code and then simply copy-paste it, as our goal was to understand how our code functions. We also found that ChatGPT is effective in identifying careless mistakes but less effective in specialized R applications related to movement data. Additionally, ChatGPT and DeepL were used to check our written text for errors and improve the sentences, but not to generate the text itself.</p>
<section id="appendix" class="level2">
<h2 class="anchored" data-anchor-id="appendix">Appendix</h2>
<section id="wordcount" class="level3">
<h3 class="anchored" data-anchor-id="wordcount">Wordcount</h3>
<!-- after installing the wordcountadding, remove the line "#| eval: false" -->
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># install.packages("pacman") </span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"pacman"</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>wordcountaddin<span class="sc">::</span><span class="fu">word_count</span>(<span class="st">"index.qmd"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2298</code></pre>
</div>
</div>

</section>
</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-sehra2013" class="csl-entry" role="listitem">
Sehra, Sukhjit Singh, Jaiteg Singh, and Hardeep Singh Rai. 2013. <span>“Assessment of OpenStreetMap Data-a Review.”</span> <em>arXiv Preprint arXiv:1309.6608</em>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>